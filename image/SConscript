# SPDX-License-Identifier: BSD-3-Clause
"""
Disk image build configuration.
"""

import os
import re

from SCons.Action import Action
from SCons.Environment import Environment
from SCons.Script import Flatten

from scripts.scons.utility import GlobRecursive
from scripts.scons.disk import (
    DiskImage,
    copy_c_library,
    install_grub,
    get_current_user,
)
from scripts.scons.arch import get_arch_config

Import('core')
Import('user_libraries')
Import('user_applications')
Import('TARGET_ENVIRONMENT')

TARGET_ENVIRONMENT: Environment
env: Environment = TARGET_ENVIRONMENT


# =============================================================================
# Build Functions
# =============================================================================

def build_disk(image_path, core_exe, libraries, applications, extra_files, env):
    """Build the complete disk image with all components.
    
    Args:
        image_path: Output disk image path
        core_exe: Kernel executable path
        libraries: List of user library paths
        applications: List of user application paths
        extra_files: Additional files to copy
        env: SCons environment
    """
    import sh
    import shutil
    
    size = env['imageSize']
    filesystem = env['imageFS']
    partition_offset = 2048
    toolchain_prefix = env.get('TOOLCHAIN_PREFIX', '')
    arch = env.get('arch', 'i686')
    
    # Get architecture configuration
    arch_config = get_arch_config(arch)
    target_triple = arch_config['target_triple']
    
    current_user = get_current_user()
    
    # Create and setup disk image
    disk = DiskImage(image_path, size, sector_size=512)
    disk.create()
    
    print("   PARTITIONING")
    disk.create_partition_table(offset=partition_offset, filesystem=filesystem)
    
    print("   FORMATTING DISK")
    disk.format_partition(filesystem, partition_offset, label='VALKYRIE')
    
    # Mount and populate the image
    tempdir = os.path.join(os.path.dirname(image_path), 'tmp_mount')
    os.makedirs(tempdir, exist_ok=True)
    
    try:
        disk.mount(tempdir)
        
        # Copy kernel
        print(f"   CP {os.path.basename(core_exe)}")
        bootdir = os.path.join(tempdir, 'boot')
        sh.sudo.mkdir('-p', bootdir)
        sh.sudo.cp(core_exe, bootdir)
        
        # Copy C library and runtime
        copy_c_library(tempdir, toolchain_prefix, target_triple, arch_config)
        
        # Copy user libraries
        if libraries:
            libdir = os.path.join(tempdir, 'usr', 'lib')
            sh.sudo.mkdir('-p', libdir)
            for lib in libraries:
                print(f"   CP {os.path.basename(lib)} /usr/lib")
                sh.sudo.cp(lib, libdir)
        
        # Copy user applications
        if applications:
            bindir = os.path.join(tempdir, 'usr', 'bin')
            sh.sudo.mkdir('-p', bindir)
            for app in applications:
                print(f"   CP {os.path.basename(app)} /usr/bin")
                sh.sudo.cp(app, bindir)
        
        # Copy extra files preserving directory structure
        src_root = env['BASEDIR']
        for file in extra_files:
            file_src = file.srcnode().path
            file_rel = os.path.relpath(file_src, src_root)
            file_dst = os.path.join(tempdir, file_rel)
            
            if os.path.isdir(file_src):
                print('   MKDIR', file_rel)
                sh.sudo.mkdir('-p', file_dst)
            else:
                print('   CP', file_rel)
                sh.sudo.cp(file_src, file_dst)
        
        # Install GRUB bootloader
        install_grub(tempdir)
        
    finally:
        try:
            print(f"   UMOUNT {tempdir}")
            disk.unmount(tempdir)
            shutil.rmtree(tempdir, ignore_errors=True)
        except Exception as e:
            print(f"Error during cleanup: {e}")
            raise
    
    # Fix ownership of generated files
    print(f"   CHOWN {current_user} {image_path}")
    sh.sudo.chown(f'{current_user}:{current_user}', image_path)
    sh.sudo.chown('-R', f'{current_user}:{current_user}', 'build/')


def build_image_action(target, source, env):
    """SCons action to build the disk image."""
    # Find kernel executable in sources
    kernel_name = env["kernelName"]
    core_exe = None
    
    for src in source:
        path = str(src)
        basename = os.path.basename(path)
        if basename == kernel_name or basename.startswith(kernel_name + '.'):
            core_exe = path
            break
        # Fallback: match by pattern
        if re.search(r'(kernel|core)', basename):
            if path.endswith(('.elf', '.bin', '.iso')):
                core_exe = path
                break
    
    if core_exe is None:
        raise RuntimeError("Kernel executable not found in build inputs")
    
    # Process library list
    lib_nodes = Flatten(user_libraries)
    libs, lib_paths = [], set()
    for lib in lib_nodes:
        path = lib.get_abspath() if hasattr(lib, 'get_abspath') else str(lib)
        libs.append(path)
        lib_paths.add(str(lib))
    
    # Process application list
    app_nodes = Flatten(user_applications)
    apps, app_paths = [], set()
    for app in app_nodes:
        path = app.get_abspath() if hasattr(app, 'get_abspath') else str(app)
        apps.append(path)
        app_paths.add(str(app))
    
    # Filter extra files (not kernel, libs, or apps)
    extra = [
        src for src in source
        if str(src) != core_exe and str(src) not in lib_paths and str(src) not in app_paths
    ]
    
    build_disk(str(target[0]), core_exe, libs, apps, extra, env)


# =============================================================================
# Build Target
# =============================================================================

root = env.Dir('root')
root_content = GlobRecursive(env, '*', root)

inputs = [core] + user_libraries + user_applications + root_content

output_fmt = env["outputFormat"]
output = f'{env["outputFile"]}_{env["config"]}_{env["arch"]}.{output_fmt}'

image = env.Command(
    output,
    inputs,
    action=Action(build_image_action, '   CREATING DISK'),
    BASEDIR=root.srcnode().path,
)

Export('image')
