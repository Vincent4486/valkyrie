# SPDX-License-Identifier: BSD-3-Clause
"""
Disk image build configuration.
"""

import os
import re
import shutil
import tempfile

from SCons.Action import Action
from SCons.Environment import Environment
from SCons.Script import Flatten

from scripts.scons.utility import GlobRecursive
from scripts.scons.disk import (
    DiskImage,
    create_iso_image,
    copy_c_library,
    install_grub,
)
from scripts.scons.arch import get_arch_config

Import('core')
Import('user_libraries')
Import('user_applications')
Import('TARGET_ENVIRONMENT')

TARGET_ENVIRONMENT: Environment
env: Environment = TARGET_ENVIRONMENT


# =============================================================================
# Build Functions
# =============================================================================

def _stage_image_tree(core_exe, libraries, applications, extra_files, env):
    """Create and populate a temporary staging tree for image contents.
    
    Args:
        core_exe: Kernel executable path
        libraries: List of user library paths
        applications: List of user application paths
        extra_files: Additional files to copy
        env: SCons environment
    """
    stage_dir = tempfile.mkdtemp(prefix='valkyrie_image_')

    # Copy kernel
    print(f"   CP {os.path.basename(core_exe)}")
    bootdir = os.path.join(stage_dir, 'boot')
    os.makedirs(bootdir, exist_ok=True)
    shutil.copy2(core_exe, bootdir)

    toolchain_prefix = env.get('TOOLCHAIN_PREFIX', '')
    arch = env.get('arch', 'i686')

    # Get architecture configuration
    arch_config = get_arch_config(arch)
    target_triple = arch_config['target_triple']

    # Copy C library and runtime
    copy_c_library(stage_dir, toolchain_prefix, target_triple, arch_config)

    # Copy user libraries
    if libraries:
        libdir = os.path.join(stage_dir, 'usr', 'lib')
        os.makedirs(libdir, exist_ok=True)
        for lib in libraries:
            print(f"   CP {os.path.basename(lib)} /usr/lib")
            shutil.copy2(lib, libdir)

    # Copy user applications
    if applications:
        bindir = os.path.join(stage_dir, 'usr', 'bin')
        os.makedirs(bindir, exist_ok=True)
        for app in applications:
            print(f"   CP {os.path.basename(app)} /usr/bin")
            shutil.copy2(app, bindir)

    # Copy extra files preserving directory structure
    src_root = env['BASEDIR']
    for file in extra_files:
        file_src = file.srcnode().path
        file_rel = os.path.relpath(file_src, src_root)
        file_dst = os.path.join(stage_dir, file_rel)

        if os.path.isdir(file_src):
            print('   MKDIR', file_rel)
            os.makedirs(file_dst, exist_ok=True)
        else:
            print('   CP', file_rel)
            os.makedirs(os.path.dirname(file_dst), exist_ok=True)
            shutil.copy2(file_src, file_dst)

    return stage_dir


def build_hd(image_path, core_exe, libraries, applications, extra_files, env):
    """Build an HD image using guestfish (no root/losetup)."""
    size = env['imageSize']
    filesystem = env['imageFS']
    partition_offset = 2048

    stage_dir = _stage_image_tree(core_exe, libraries, applications, extra_files, env)

    try:
        disk = DiskImage(image_path, size, sector_size=512)
        disk.create()

        print("   PARTITIONING")
        disk.create_partition_table(offset=partition_offset, filesystem=filesystem)

        print("   FORMATTING DISK")
        disk.format_partition(filesystem, partition_offset, label='VALKYRIE')

        install_grub(image_path, stage_dir)

        print("   POPULATING DISK")
        disk.populate_from_directory(stage_dir)
    finally:
        shutil.rmtree(stage_dir, ignore_errors=True)


def build_iso(image_path, core_exe, libraries, applications, extra_files, env):
    """Build an ISO image with xorriso."""
    stage_dir = _stage_image_tree(core_exe, libraries, applications, extra_files, env)

    try:
        print("   CREATING ISO")
        create_iso_image(image_path, stage_dir, volume_label='VALKYRIE')
    finally:
        shutil.rmtree(stage_dir, ignore_errors=True)


def build_image_action(target, source, env):
    """SCons action to build HD/ISO images."""
    # Find kernel executable in sources
    kernel_name = env["kernelName"]
    core_exe = None
    
    for src in source:
        path = str(src)
        basename = os.path.basename(path)
        if basename == kernel_name or basename.startswith(kernel_name + '.'):
            core_exe = path
            break
        # Fallback: match by pattern
        if re.search(r'(kernel|core)', basename):
            if path.endswith(('.elf', '.bin', '.iso')):
                core_exe = path
                break
    
    if core_exe is None:
        raise RuntimeError("Kernel executable not found in build inputs")
    
    # Process library list
    lib_nodes = Flatten(user_libraries)
    libs, lib_paths = [], set()
    for lib in lib_nodes:
        path = lib.get_abspath() if hasattr(lib, 'get_abspath') else str(lib)
        libs.append(path)
        lib_paths.add(str(lib))
    
    # Process application list
    app_nodes = Flatten(user_applications)
    apps, app_paths = [], set()
    for app in app_nodes:
        path = app.get_abspath() if hasattr(app, 'get_abspath') else str(app)
        apps.append(path)
        app_paths.add(str(app))
    
    # Filter extra files (not kernel, libs, or apps)
    extra = [
        src for src in source
        if str(src) != core_exe and str(src) not in lib_paths and str(src) not in app_paths
    ]
    
    output_format = env['outputFormat']
    image_path = str(target[0])
    if output_format == 'hd':
        build_hd(image_path, core_exe, libs, apps, extra, env)
    elif output_format == 'iso':
        build_iso(image_path, core_exe, libs, apps, extra, env)
    else:
        raise RuntimeError(f"Unsupported outputFormat: {output_format}")


# =============================================================================
# Build Target
# =============================================================================

root = env.Dir('root')
root_content = GlobRecursive(env, '*', root)

inputs = [core] + user_libraries + user_applications + root_content

output_fmt = env["outputFormat"]
output = f'{env["outputFile"]}_{env["config"]}_{env["arch"]}.{output_fmt}'

image = env.Command(
    output,
    inputs,
    action=Action(build_image_action, '   CREATING IMAGE'),
    BASEDIR=root.srcnode().path,
)

Export('image')
